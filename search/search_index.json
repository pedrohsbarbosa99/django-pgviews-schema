{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Django SQL Views for PG with schema","text":"<p>Welcome to our project documentation! We provide first-class support for PostgreSQL Views in the Django ORM, along with custom schema support.</p> <p>This project is a fork of the original django-pgviews-redux by xelixdev, PostgreSQL schemas.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Custom schema support</li> <li>Compatibility with Django 3.2+</li> </ul>"},{"location":"#about-the-project","title":"About the Project","text":"<p>Our documentation aims to provide comprehensive information on utilizing PostgreSQL Views in Django, as well as custom schema features. You'll find detailed insights, examples, and guides to make the most of this functionality in your Django projects.</p> <p>Explore our documentation to harness the power of PostgreSQL Views and streamline your Django development!</p> <p>Disclaimer: This project will be actively maintained until the original project implements the schema discovery feature. Once the original project adds this feature, we encourage you to transition back to it for ongoing support and updates. Our goal is to provide a solution in the interim and support the community's needs until the feature is available in the official project.</p>"},{"location":"compatibility/","title":"Django Compatibility","text":"Django Version Django-PGView Version 3.2 0.0.1 4.0 0.0.1 4.1 0.0.3 4.2 0.0.4 5.0 0.0.4"},{"location":"compatibility/#python-3-support","title":"Python 3 Support","text":"<p>Django PGViews Redux officially supports Python 3.7+ and may work on 3.6, but there are no guarantees.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#updating-views","title":"Updating Views","text":"<p>Sometimes your models change and you need your Database Views to reflect the new data. Updating the View logic is as simple as modifying the underlying SQL and running:</p> <pre><code>python manage.py sync_pgviews --force\n</code></pre> <p>This will forcibly update any views that conflict with your new SQL.</p>"},{"location":"features/#dependencies","title":"Dependencies","text":"<p>You can specify other views you depend on. This ensures the other views are installed beforehand. Using dependencies also ensures that your views get refreshed correctly when using <code>sync_pgviews --force</code>.</p> <p>Note: Views are synced after the Django application has migrated and adding models to the dependency list will cause syncing to fail.</p> <p>Example:</p> <pre><code>from django_pgviews import view as pg\n\nclass PreferredCustomer(pg.View):\n    dependencies = ['myapp.OtherView',]\n    sql = \"\"\"SELECT * FROM myapp_customer WHERE is_preferred = TRUE;\"\"\"\n\n    class Meta:\n      app_label = 'myapp'\n      db_table = 'myapp_preferredcustomer'\n      managed = False\n</code></pre>"},{"location":"features/#materialized-views","title":"Materialized Views","text":"<p>Postgres 9.3 and up supports materialized views which allow you to cache the results of views, potentially allowing them to load faster.</p> <p>However, you do need to manually refresh the view. To do this automatically, you can attach signals and call the refresh function.</p> <p>Example:</p> <pre><code>from django_pgviews import view as pg\n\n\nVIEW_SQL = \"\"\"\n    SELECT name, post_code FROM myapp_customer WHERE is_preferred = TRUE\n\"\"\"\n\nclass Customer(models.Model):\n    name = models.CharField(max_length=100)\n    post_code = models.CharField(max_length=20)\n    is_preferred = models.BooleanField(default=True)\n\n\nclass PreferredCustomer(pg.MaterializedView):\n    name = models.CharField(max_length=100)\n    post_code = models.CharField(max_length=20)\n\n    sql = VIEW_SQL\n\n\n@receiver(post_save, sender=Customer)\ndef customer_saved(sender, action=None, instance=None, **kwargs):\n    PreferredCustomer.refresh()\n</code></pre>"},{"location":"features/#concurrent-refresh","title":"Concurrent refresh","text":"<p>Postgres 9.4 and up allow materialized views to be refreshed concurrently, without blocking reads, as long as a unique index exists on the materialized view. To enable concurrent refresh, specify the name of a column that can be used as a unique index on the materialized view. Unique index can be defined on more than one column of a materialized view. Once enabled, passing <code>concurrently=True</code> to the model's refresh method will result in postgres performing the refresh concurrently. (Note that the refresh method itself blocks until the refresh is complete; concurrent refresh is most useful when materialized views are updated in another process or thread.)</p> <p>Example:</p> <pre><code>from django_pgviews import view as pg\n\n\nVIEW_SQL = \"\"\"\n    SELECT id, name, post_code FROM myapp_customer WHERE is_preferred = TRUE\n\"\"\"\n\nclass PreferredCustomer(pg.MaterializedView):\n    concurrent_index = 'id, post_code'\n    sql = VIEW_SQL\n\n    name = models.CharField(max_length=100)\n    post_code = models.CharField(max_length=20)\n\n\n@receiver(post_save, sender=Customer)\ndef customer_saved(sender, action=None, instance=None, **kwargs):\n    PreferredCustomer.refresh(concurrently=True)\n</code></pre>"},{"location":"features/#indexes","title":"Indexes","text":"<p>As the materialized view isn't defined through the usual Django model fields, any indexes defined there won't be created on the materialized view. Luckily Django provides a Meta option called <code>indexes</code> which can be used to add custom indexes to models. <code>pg_views</code> supports defining indexes on materialized views using this option.</p> <p>In the following example, one index will be created, on the <code>name</code> column. The <code>db_index=True</code> on the field definition for <code>post_code</code> will get ignored.</p> <pre><code>from django_pgviews import view as pg\n\n\nVIEW_SQL = \"\"\"\n    SELECT id, name, post_code FROM myapp_customer WHERE is_preferred = TRUE\n\"\"\"\n\nclass PreferredCustomer(pg.MaterializedView):\n    sql = VIEW_SQL\n\n    name = models.CharField(max_length=100)\n    post_code = models.CharField(max_length=20, db_index=True)\n\n    class Meta:\n        managed = False  # don't forget this, otherwise Django will think it's a regular model\n        indexes = [\n             models.Index(fields=[\"name\"]),\n        ]\n</code></pre>"},{"location":"features/#with-no-data","title":"WITH NO DATA","text":"<p>Materialized views can be created either with or without data. By default, they are created with data, however <code>pg_views</code> supports creating materialized views without data, by defining <code>with_data = False</code> for the <code>pg.MaterializedView</code> class. Such views then do not support querying until the first refresh (raising <code>django.db.utils.OperationalError</code>).</p> <p>Example:</p> <pre><code>from django_pgviews import view as pg\n\nclass PreferredCustomer(pg.MaterializedView):\n    concurrent_index = 'id, post_code'\n    sql = \"\"\"\n        SELECT id, name, post_code FROM myapp_customer WHERE is_preferred = TRUE\n    \"\"\"\n    with_data = False\n\n    name = models.CharField(max_length=100)\n    post_code = models.CharField(max_length=20)\n</code></pre>"},{"location":"features/#conditional-materialized-views-recreate","title":"Conditional materialized views recreate","text":"<p>Since all materialized views are recreated on running <code>migrate</code>, it can lead to obsolete recreations even if there were no changes to the definition of the view. To prevent this, version 0.7.0 and higher contain a feature which checks existing materialized view definition in the database (if the mat. view exists at all) and compares the definition with the one currently defined in your <code>pg.MaterializedView</code> subclass. If the definition matches exactly, the re-create of materialized view is skipped.</p> <p>This feature is enabled by setting the <code>MATERIALIZED_VIEWS_CHECK_SQL_CHANGED</code> in your Django settings to <code>True</code>, which enables the feature when running <code>migrate</code>. The command <code>sync_pgviews</code> uses this setting as well, however it also has switches <code>--enable-materialized-views-check-sql-changed</code> and <code>--disable-materialized-views-check-sql-changed</code> which override this setting for that command.</p> <p>This feature also takes into account indexes. When a view is deemed not needing recreating, the process will still check the indexes on the table and delete any extra indexes and create any missing indexes. This reconciliation is done through the index name, so if you use custom names for your indexes, it might happen that it won't get updated on change of the content but not the name.</p>"},{"location":"features/#custom-schema","title":"Custom Schema","text":"<p>You can define any table name you wish for your views. They can even live inside your own custom PostgreSQL schema.</p> <pre><code>from django_pgviews import view as pg\n\n\nclass PreferredCustomer(pg.View):\n    sql = \"\"\"SELECT * FROM myapp_customer WHERE is_preferred = TRUE;\"\"\"\n\n    class Meta:\n      db_table = 'my_custom_schema.preferredcustomer'\n      managed = False\n</code></pre>"},{"location":"features/#dynamic-view-sql","title":"Dynamic View SQL","text":"<p>If you need a dynamic view SQL (for example if it needs a value from settings in it), you can override the <code>run_sql</code> classmethod on the view to return the SQL. The method should return a namedtuple <code>ViewSQL</code>, which contains the query and potentially the params to <code>cursor.execute</code> call. Params should be either None or a list of parameters for the query.</p> <pre><code>from django.conf import settings\nfrom django_pgviews import view as pg\n\n\nclass PreferredCustomer(pg.View):\n    @classmethod\n    def get_sql(cls):\n        return pg.ViewSQL(\n            \"\"\"SELECT * FROM myapp_customer WHERE is_preferred = TRUE and created_at &gt;= %s;\"\"\",\n            [settings.MIN_PREFERRED_CUSTOMER_CREATED_AT]\n        )\n\n    class Meta:\n      db_table = 'preferredcustomer'\n      managed = False\n</code></pre>"},{"location":"features/#sync-listeners","title":"Sync Listeners","text":"<p>django-pgviews 0.5.0 adds the ability to listen to when a <code>post_sync</code> event has occurred.</p>"},{"location":"features/#view_synced","title":"<code>view_synced</code>","text":"<p>Fired every time a VIEW is synchronised with the database.</p> <p>Provides args:</p> <ul> <li><code>sender</code> - View Class</li> <li><code>update</code> - Whether the view to be updated</li> <li><code>force</code> - Whether <code>force</code> was passed</li> <li><code>status</code> - The result of creating the view e.g. <code>EXISTS</code>, <code>FORCE_REQUIRED</code></li> <li><code>has_changed</code> - Whether the view had to change</li> </ul>"},{"location":"features/#all_views_synced","title":"<code>all_views_synced</code>","text":"<p>Sent after all Postgres VIEWs are synchronised.</p> <p>Provides args:</p> <ul> <li><code>sender</code> - Always <code>None</code></li> </ul>"},{"location":"features/#multiple-databases","title":"Multiple databases","text":"<p>django-pgviews can use multiple databases. Similar to Django's <code>migrate</code> management command, our commands (<code>clear_pgviews</code>, <code>refresh_pgviews</code>, <code>sync_pgviews</code>) operate on one database at a time. You can specify which database to synchronize by providing the <code>--database</code> option. For example:</p> <pre><code>python manage.py sync_pgviews  # uses default db\npython manage.py sync_pgviews --database=myotherdb\n</code></pre> <p>Unless using custom routers, django-pgviews will sync all views to the specified database. If you want to interact with multiple databases automatically, you'll need to take some additional steps. Please refer to Django's Automatic database routing to pin views to specific databases.</p>"},{"location":"get_started/","title":"Get Started","text":""},{"location":"get_started/#examples","title":"Examples","text":"<pre><code>from django.db import models\n\nfrom django_pgviews import view as pg\n\n\nclass Customer(models.Model):\n    name = models.CharField(max_length=100)\n    post_code = models.CharField(max_length=20)\n    is_preferred = models.BooleanField(default=False)\n\n    class Meta:\n        app_label = 'myapp'\n\nclass PreferredCustomer(pg.View):\n    projection = ['myapp.Customer.*',]\n    dependencies = ['myapp.OtherView',]\n    sql = \"\"\"SELECT * FROM myapp_customer WHERE is_preferred = TRUE;\"\"\"\n\n    class Meta:\n      app_label = 'myapp'\n      db_table = 'myapp_preferredcustomer'\n      managed = False\n</code></pre> <p>NOTE It is important that we include the <code>managed = False</code> in the <code>Meta</code> so Django 1.7 migrations don't attempt to create DB tables for this view.</p> <p>The SQL produced by this might look like:</p> <pre><code>CREATE VIEW myapp_preferredcustomer AS\nSELECT * FROM myapp_customer WHERE is_preferred = TRUE;\n</code></pre> <p>To create all your views, run <code>python manage.py sync_pgviews</code></p> <p>You can also specify field names, which will map onto fields in your View:</p> <pre><code>from django_pgviews import view as pg\n\n\nVIEW_SQL = \"\"\"\n    SELECT name, post_code FROM myapp_customer WHERE is_preferred = TRUE\n\"\"\"\n\n\nclass PreferredCustomer(pg.View):\n    name = models.CharField(max_length=100)\n    post_code = models.CharField(max_length=20)\n\n    sql = VIEW_SQL\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>Install via pip:</p> <pre><code>pip install django-pgviews-schema\n</code></pre> <p>Add to installed applications in settings.py:</p> <pre><code>INSTALLED_APPS = (\n  # ...\n  'django_pgviews',\n)\n</code></pre>"},{"location":"settings/","title":"Settings","text":"<p>NOTE You need set <code>DEFAULT_SCHEMA</code> in your settings.py if your database use custom schema.</p> <p>Add <code>DEFAULT_SCHEMA</code> in settings.py:</p> <pre><code># settings.py\n...\nDEFAULT_SCHEMA = \"your_custom_schema\" # default is public if not set\n...\n</code></pre> <p>You can also sen ENV variable <code>PG_DEFAULT_VIEW_SCHEMA</code> to set the default schema.</p>"},{"location":"usage/","title":"Usage","text":"<p>To map onto a View, simply extend <code>pg_views.view.View</code>, assign SQL to the <code>sql</code> argument and define a <code>db_table</code>. You must always set <code>managed = False</code> on the <code>Meta</code> class.</p> <p>Views can be created in a number of ways:</p> <ol> <li>Define fields to map onto the VIEW output</li> <li>Define a projection that describes the VIEW fields</li> </ol>"},{"location":"usage/#define-fields","title":"Define Fields","text":"<p>Define the fields as you would with any Django Model:</p> <pre><code>from django_pgviews import view as pg\n\n\nVIEW_SQL = \"\"\"\n    SELECT name, post_code FROM myapp_customer WHERE is_preferred = TRUE\n\"\"\"\n\n\nclass PreferredCustomer(pg.View):\n    name = models.CharField(max_length=100)\n    post_code = models.CharField(max_length=20)\n\n    sql = VIEW_SQL\n\n    class Meta:\n      managed = False\n      db_table = 'my_sql_view'\n</code></pre>"},{"location":"usage/#define-projection","title":"Define Projection","text":"<p><code>django-pgviews</code> can take a projection to figure out what fields it needs to map onto for a view. To use this, set the <code>projection</code> attribute:</p> <pre><code>from django_pgviews import view as pg\n\n\nclass PreferredCustomer(pg.View):\n    projection = ['myapp.Customer.*',]\n    sql = \"\"\"SELECT * FROM myapp_customer WHERE is_preferred = TRUE;\"\"\"\n\n    class Meta:\n      db_table = 'my_sql_view'\n      managed = False\n</code></pre> <p>This will take all fields on <code>myapp.Customer</code> and apply them to <code>PreferredCustomer</code></p>"}]}